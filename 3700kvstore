#!/usr/bin/env python


import sys, socket, select, time, json, random, datetime
from message import Message
from Server import Server

my_id = sys.argv[1]

#Todo: set this / 2 + 1 to SERVER.quorum size
replica_ids = sys.argv[2:]

SERVER = Server(my_id, replica_ids)

time.sleep(0.2)

while True:
    if SERVER.election_timedout():
        print str(SERVER.id) + ": election_timedout"

        SERVER.initiate_election()

    if SERVER.node_state == "L":
        print str(SERVER.id) + " LEADER"
        SERVER.send_heartbeat()

    if SERVER.node_state == "F":
        pass

    if SERVER.node_state == "C":
        # #TODO: if received heartbeat, if heartbeat term >= SERVER.term, become follower and ACK
        # if SERVER.election_timedout():
        #     print str(SERVER.id) + ": candidate ELECTION TIMEDOUT _ RESTART ELECTION"
        #     SERVER.initiate_election()
        pass

    print str(SERVER.id) + ": Node State = " + str(SERVER.node_state)

    ready = select.select([SERVER.sock], [], [], 0.1)[0]

    if SERVER.sock in ready:
        #print str(SERVER.id) + ": Ready"
        msg_raw = SERVER.sock.recv(32768)

        if len(msg_raw) == 0:
            continue

        msg = json.loads(msg_raw)

        # if NODE_STATE == "L": - run leader directions
        #    - check self.timeout:
        #           if timedout: change NODE_STATE to "F", initiate election cycle
        #           else: continue (continue listening for messages from client, sending updates to followers)
        if SERVER.node_state == "L":
            # For now, ignore get() and put() from clients
            if msg['type'] in ['get', 'put']:
                message = Message.create_message_from_json(msg)

            elif msg['type'] == 'heartbeatACK':
                message = Message.create_message_from_json(msg)
                SERVER.get_new_election_timeout()
                #TODO: commit log entry yet?????
                pass

            if msg['type'] == 'heartbeat':

                message = Message.create_message_from_json(msg)

                if message.term > SERVER.current_term:
                    SERVER.become_follower(message.leader)


        # if NODE_STATE == "C": - run candidate directions
        #    - check election_timeout:
        #           if election_timedut:...
        #           else: continue (listen for votes, if received enough votes, determine the leader, etc.)
        if SERVER.node_state == "C":
            #print str(SERVER.id) + ": Message: " + str(msg)

            # if msg['type'] == 'heartbeat':
            #     print str(SERVER.id) + ": got heartbeat"
            #     SERVER.get_new_election_timeout()
            #     SERVER.node_state = "F"
            #     SERVER.voted_for = None

            if msg['type'] == 'vote':
                print str(SERVER.id) + ": Got Vote Message----------"
                message = Message.create_message_from_json(msg)
                SERVER.receive_vote(message)

            if msg['type'] == 'heartbeat':
                message = Message.create_message_from_json(msg)

                if message.term >= SERVER.current_term:
                    SERVER.become_follower(message.leader)



        # if NODE_STATE == "F": - run follower directions
        #    - check leader_timeout:
        #           -if timedout, request election
        #           -else: continue (listen for messages from leader)
        if SERVER.node_state == "F":
            # print str(SERVER.id) + " FOLLOWER GOT " + str(msg)

            if msg['type'] == 'heartbeat':
                if msg['term'] == SERVER.current_term:
                    print str(SERVER.id) + ": got heartbeat"
                    heart_beat = Message.create_message_from_json(msg)
                    SERVER.leader_id = heart_beat.leader
                    SERVER.get_new_election_timeout()
                    hb_ack = heart_beat.create_heart_beat_ACK_message(SERVER.id)
                    SERVER.send(hb_ack)

            if msg['type'] == 'voteRequest':
                print str(SERVER.id) + ": RECEIVED VOTE REQUEST"

                vote_req_message = Message.create_message_from_json(msg)
                if vote_req_message.term > SERVER.current_term:
                    if SERVER.voted_for is None or SERVER.voted_for == vote_req_message.src:
                        # TODO: and canddiates log is at least up to date as receiver's log, grand vote
                        SERVER.send_vote(vote_req_message)
                    SERVER.get_new_election_timeout()

            if msg['type'] in ['get', 'put']:
                message = Message.create_message_from_json(msg)
                redirect_message = message.create_redirect_message(SERVER.leader_id)

                SERVER.send(redirect_message)



        # Handle noop messages. This may be removed from your final implementation
        elif msg['type'] == 'noop':
            print '%s received a NOOP from %s' % (msg['dst'], msg['src'])

    '''
    clock = time.time()
    if clock-last > 2:
        # Send a no-op message to a random peer every two seconds, just for fun
        # You definitely want to remove this from your implementation
        msg = {'src': my_id, 'dst': random.choice(replica_ids), 'leader': 'FFFF', 'type': 'noop'}
        sock.send(json.dumps(msg))
        print '%s sending a NOOP to %s' % (msg['src'], msg['dst'])
        last = clock
    '''



