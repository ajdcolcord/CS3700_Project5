#!/usr/bin/env python

import sys, socket, select, time, json, random, datetime
from message import Message

# Your ID number
my_id = sys.argv[1]
# my_id = 1111

# The ID numbers of all the other replicas
replica_ids = sys.argv[2:]

# Connect to the network. All messages to/from other replicas and clients will
# occur over this socket
sock = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
sock.connect(my_id)

last = 0

KEY_VALUE_STORE = {}
# Node state: Follower, Candidate, Leader
NODE_STATE = "F"
LEADER_ADDRESS = 0
# Random # between 150 and 300 ms
ELECTION_TIMEOUT = get_new_election_timeout()
ELECTION_TIMEOUT_START = datetime.datetime.now()

# If the node doesn't hear from a leader they become a candidate.
# The candidate then requests votes from other nodes
# Nodes reply with their votes
# Leader Election - Candidate becomes leader with majority of votes
# All changes to the system now go through the leader
# Each change is added as an entry in the leaders log
# The log entry is uncommitted so it won't update the node's value
# To commit the entry the node first replicates it to the follower nodes
# The leader waits until the majority have written the entry
# The entry is now committed on the leader
# The leader then notifies the followers that the entry is committed
# This is log replication
#
#
# Leader Election:
# There are two timeout settings that control elections
# Election timeout - The amount of time a follower waits to become a candidate
# ET is randomized between 150 and 300 ms
# After the election timeout the follower becomes a candidate and starts a new election term and votes for itself
# The candidate then sends out vote requests to other nodes
# if the receiving node has not yet voted in this election term then it votes for the candidate
# and the node resets its election timeout
# Once a candidate has the majority it becomes the leader
# The leader begins sending out Append Entries messages to its followers.
# These messages are sent in intervals specified by the heartbeat timeout.
# Followers then respond to each Append Entries message.
# This election term will continue until a follower stops receiving heartbeats and becomes a candidate.
# Let's stop the leader and watch a re-election happen.
# Node C is now leader of term 2.
# Requiring a majority of votes guarantees that only one leader can be elected per term.
# If two nodes become candidates at the same time then a split vote can occur.
# Let's take a look at a split vote example...
# Two nodes both start an election for the same term...
# ...and each reaches a single follower node before the other.
# Now each candidate has 2 votes and can receive no more for this term.
# The nodes will wait for a new election and try again.
# Node C received a majority of votes in term 5 so it becomes leader.
#
# Log Replication
# Once we have a leader elected we need to replicate all changes to our system to all nodes.
# This is done by using the same Append Entries message that was used for heartbeats.
# Let's walk through the process.
# First a client sends a change to the leader.
# The change is appended to the leader's log...
# ...then the change is sent to the followers on the next heartbeat.
# An entry is committed once a majority of followers acknowledge it...
# ...and a response is sent to the client.
# Now let's send a command to increment the value by "2".
# Our system value is now updated to "7". (Started at 5)
# Raft can even stay consistent in the face of network partitions.
# Let's add a partition to separate A & B from C, D & E.
# Because of our partition we now have two leaders in different terms.
# Let's add another client and try to update both leaders.
# One client will try to set the value of node B to "3".
# Node B cannot replicate to a majority so its log entry stays uncommitted.
# The other client will try to set the value of node C to "8".
# This will succeed because it can replicate to a majority.
# Now let's heal the network partition.
# Node B will see the higher election term and step down.
# Both nodes A & B will roll back their uncommitted entries and match the new leader's log.
# Our log is now consistent across our cluster.
#



def action(message):
    global KEY_VALUE_STORE

    if message.type == 'get':
        get(message)
    elif message.type == 'put':
        put(message)


def get(message):
    global KEY_VALUE_STORE

    print "Get"
    if message.key not in KEY_VALUE_STORE:
        send(message.create_fail_message())

    else:
        send(message.create_ok_get_message(KEY_VALUE_STORE[message.key]))


def put(message):
    global KEY_VALUE_STORE

    print "Put"

    put_into_store(message.key, message.value)
    print "Added " + str(message.key) + " with value " + str(message.value)

    #assuming successful
    send(message.create_ok_put_message())

def put_into_store(key, value):
    global KEY_VALUE_STORE

    KEY_VALUE_STORE[key] = value


def send(json_message):
    print "sending"

    try:
        sock.send(json.dumps(json_message))
    except:
        raise Exception("Could not successfully send message")

def am_i_leader():
    global LEADER_ADDRESS
    global my_id

    return LEADER_ADDRESS == my_id

def is_election_over():
    global ELECTION_TIMEOUT_START

    return (datetime.datetime.now() - ELECTION_TIMEOUT_START) > ELECTION_TIMEOUT

def get_new_election_timeout():
    return random.randint(150,300)

def send_vote_request():
    # Send a vote request message to all other followers
    return 1


while True:
    ready = select.select([sock], [], [], 0.1)[0]

    if sock in ready:
        msg_raw = sock.recv(32768)

        if len(msg_raw) == 0:
            continue

        msg = json.loads(msg_raw)

        # For now, ignore get() and put() from clients
        if msg['type'] in ['get', 'put']:
            message = Message.create_message_from_json(msg)

            action(message)

        # Handle noop messages. This may be removed from your final implementation
        elif msg['type'] == 'noop':
            print '%s received a NOOP from %s' % (msg['dst'], msg['src'])

    '''
    clock = time.time()
    if clock-last > 2:
        # Send a no-op message to a random peer every two seconds, just for fun
        # You definitely want to remove this from your implementation
        msg = {'src': my_id, 'dst': random.choice(replica_ids), 'leader': 'FFFF', 'type': 'noop'}
        sock.send(json.dumps(msg))
        print '%s sending a NOOP to %s' % (msg['src'], msg['dst'])
        last = clock
    '''



